Implementarea procedurilor in x86 - conventii de scriere 

Am vazut deja modul in care se apeleaza procedurile, lucrand cu printf, scanf, fflush. 
- se dadeau argumentele procedurii, in ordine inversa;
- se apela procedura prin intermediul instructiunii call. 

proc(arg1, arg2, ..., argn)

pushl argn
...
pushl arg2
pushl arg1
call proc 

- pentru fiecare argument pe care l-am dat procedurii (argument care este pus pe stiva), trebuie sa facem si un pop(l). 

popl %ebx <-- %ebx este acum un registru care nu are o informatie semnificativa 
popl %ebx
...
popl %ebx <-- am efectuat n pop-uri din stiva

-- Exemplu

printf("Suma numerelor este: %d\n", s);

pushl s 
pushl $formatPrintf
call printf
popl %ebx
popl %ebx

Mecanismul de control privind salturile intr-o procedura si revenirea in locul de unde a fost apelata
- call - apeleaza o procedura si retine adresa de intoarcere (locul de unde procedura a fost apelata);
- ret - stie sa sara la adresa de intoarcere; 


pushl arg3
pushl arg2
pushl arg1
call printf
popl %ebx		<-- se revine in acest punct datorita instructiunii ret 
popl %ebx
popl %ebx

Stiva are urmatorul continut in momentul in care se intra in eticheta printf:

<adr. de intoarcere>
arg1
arg2
arg3



Registrul %eip <- instruction pointer, tine minte adresa urmatoarei instructiuni ce trebuie executata. 

- instructiunea ret citeste varful stivei, face pop si sare la adresa de memorie indicata in varful stivei. 


Schita unei proceduri pana in momentul de fata:

proc:
	...
	ret

main:
	
	...
	call proc
	...		<--

Stiva este controlata prin intermediul a doi registri:
- %esp (stack pointer): el este registrul prin care se efectueaza push-urile si pop-urile.
	pushl arg
	inseamna, de fapt, ca se modifica %esp si este salvata o valoare relativ la adresa de memorie indicata de %esp
  %esp indica intotdeauna varful stivei
  valoarea efectiva din varful stivei este data de 0(%esp)
  a(b, c, d) 
  pe stiva, intotdeauna se aloca spatii de 4 bytes. Cand fac un push / pop, modific, de fapt, adresa lui %esp cu 4.

Pentru fiecare push facut, adresa lui %esp scade cu 4. <-- stiva creste spre adrese de memorie mai mici
Pentru fiecare pop facut, adresa lui %esp creste cu 4. <-- stiva scade spre adrese de memorie mai mari

sub $4, %esp <-- push
add $4, %esp <-- pop 

- %ebp (base pointer): el este registrul prin care vom accesa elementele din cadrul de apel (de pe stiva). 
  %ebp este un registru utilizat ca o conventie pentru limbajul C, si este folosit mereu pentru transformarile de cod C -> asm, asm -> C. 

%ebp-ul va pointa fix in cadrul de apel. 

%ebx					<-- 0(%esp)
<adr. de intoarcere>	<-- 0(%esp)	<-- 4(%esp)
$formatPrintf		<-- 4(%esp)	<-- 8(%esp)
x			<-- 8(%esp)	<-- 12(%esp)

Utilizarea lui %ebp se face in doi pasi:
- se pune valoarea lui %ebp pe stiva, spre a fi restaurata;
- se face %ebp-ul un pointer in cadrul de apel.

%ebx			<-- 0(%esp)	-4(%ebp)
%ebp v 			<-- 0(%esp) === 0(%ebp)
<adr. de intoarcere>		    <-- 4(%ebp)
$formatPrintf			    <-- 8(%ebp)
x				    <-- 12(%ebp)


Restaurarea cadrului de apel 

movl index, %ecx
movl $15, %ebx
movl $1, %ebp
pushl x 
pushl $formatPrintf
call printf
popl %ebx
popl %ebx
<-- obligatoriu gasesc 15 in %ebx
?? %ecx 
movl index, %ecx <-- una dintre solutii

Prin conventie, procedurile dezvoltate in x86 restaureaza DOAR urmatorii registri: %ebx, %esp, %ebp, %esi, %edi. 
NU sunt restaurati urmatorii registri: %eax, %ecx, %edx.

Mecanismul de restaurare se face tot prin intermediul stivei.
In cadrul procedurii, pentru fiecare registru utilizat din lista registrilor de restaurat, facem un push pe stiva.

proc:	
	// %esp:(<adr. de intoarcere>)(arg1)(arg2)(arg3)
	pushl %ebp
	// %esp:%ebp:(%ebp v)(<adr. de intoarcere>)(arg1)(arg2)(arg3)
	// fac %ebp un pointer in cadrul de apel: movl %esp, %ebp
	pushl %ebx				<-- %ebx este pus pe stiva, pentru a avea o copie a vechii lui valori
	// %esp:(%ebx v)%ebp:(%ebp v)(<adr. de intoarcere>)(arg1)(arg2)(arg3)
	pushl %esi

	// am folosit %esi, %ebx asa cum am avut nevoie

	popl %esi
	popl %ebx
	popl %ebp 
	ret

Cum fac %ebp sa fie un pointer in cadrul de apel?
movl %esp, %ebp			// %ebp = %esp

Cum returnez valori dintr-o procedura?
%eax, %ecx, %edx, returnam prin varful stivei

adica, dupa ce fac un call catre o anumita procedura, voi gasi rezultatul acelei proceduri in registrul %eax. 

long suma(long x, long y)

%eax = suma(x, y);

pushl y
pushl x
call suma
popl %ebx
popl %ebx

// gasesc in %eax suma dintre x si y 

%esi v 
%ebp v2					<-- %ebp, 0(%ebp)
<noua adr. de intoarcere>		<-- 4(%ebp)
y 					<-- 8(%ebp)
%ebx v					<-- 12(%ebp)
%ebp v 					<-- 16(%ebp)
<adr de intoarcere>			<-- 20(%ebp)
x 


Fie x un numar natural. Sa se scrie o procedura care decide daca x este sau nu un numar perfect (= cu suma divizorilor sai, pana la jumatate). Procedura
va returna 1 in %eax daca numarul este perfect si 0 altfel.

%eax = perfect(long x);

perfect(6) -> 1 in %eax
perfect(28) -> 1 in %eax
perfect(3) -> 0 in %eax
