Proceduri in x86, sintaxa AT&T 
- suportul de laborator va fi postat in weekend; 

Mecanismul de a apela o procedura
- se incarcau parametrii procedurii pe stiva;
- se apela procedura prin instructiunea call. 

proc(arg1, arg2, arg3);

- argumentele se incarca in ordine inversa pe stiva, si anume

pushl arg3
pushl arg2
pushl arg1
call proc

- pentru fiecare push(l) facut, trebuie sa facem si un pop(l):

popl %ebx
popl %ebx
popl %ebx

- pana acum, am lucrat cu printf, fflush, scanf... 

Instructiunile call si ret
- call este instructiunea utilizata pentru a apela o procedura;
- ret este instructiunea utilizata pentru a reveni dintr-o procedura.

pushl x 
pushl $formatPrintf
call printf				-- pushl cu adresa de intoarcere
popl %ebx
popl %ebx

In x86 exista registrul %eip (instruction pointer), care tine minte adresa urmatoarei instructiuni ce va trebui executata. 
In cazul procedurilor, utilizarea instructiunii call pune pe stiva adresa de intoarcere.

<adresa de intoarcere>   <-- aici pointeza %esp    0(%esp)
$formatPrintf					   4(%esp)
x					  	   8(%esp)

- ret se leaga inapoi de locul in care a fost apelata procedura, tinand minte adresa urmatoarei instructiuni de dupa call.

Conventii de scriere a procedurilor 

- este importanta utilizarea registrului %ebp (base pointer). El este fixat, la inceputul procedurii, in cadrul de apel.

Operatiile push(l) si pop(l) modifica registrul %esp (stack pointer). 
- push(l) - sub $4, %esp - se scade 4 din valoarea curenta retinuta in stack pointer (%esp); 
- pop(l)  - add $4, %esp - se adauga 4 la valaorea curenta retinuta in stack pointer (%esp).

Stiva creste catre valori mai mici si scade catre valori mai mari. 
Registrul %esp va fi utilizat strict in operatiile push si pop, in timp ce accesarea din cadrul stivei va fi efectuata prin intermediul registrului %ebp.

%esp <- push, pop
%ebp <- accesare din cadrul stivei (accesarea argumentelor, a variabilelor locale, ...)


Conventii privind restaurarea cadrului de apel 

movl index, %ecx
movl $15, %ebx
call printf 
<-- in punctul asta, stiu sigur ca %ebx este tot 15 (restaurarea lui %ebx)
<-- in punctul asta, %ecx nu mai avea valoarea din index
printf modifica si el, intern, registrii %eax, %ebx, %ecx, %edx, %esi, %edi... 

Orice procedura care este dezvoltata in x86 este obligata sa restaureze doar valorile din registrii %ebx, %esi, %edi, %ebp, %esp. 
Asta inseamna ca, daca inainte de un call la o anumita procedura avem anumite valori stocate in %eax, %ecx, %edx, NU avem garantia ca vom gasi exact aceleasi valori
la revenirea din cadrul de apel. 

Obs: mecanismul de restaurare nu este implicit, ci trebuie asigurat de noi. 

Restaurarea se va face prin intermediul stivei, astfel:
- la intrarea in procedura, se va face push cu registrii de restaurat (%ebx, %esi, %edi) pe care ii utilizam; in acest mod, eu am pus vechea valoare a lui %ebx pe stiva.
- la iesirea din procedura, voi face pop si voi indica registrul pe care vreau sa-l restaurez. 

pushl %ebx	<-- am pus %ebx pe stiva avand, astfel, vechea lui valoare salvata
pushl %esi	<-- am pus %esi pe stiva pentru ca vreau sa-l utilizez in cadrul procedurii
pushl %edi	<-- am pus %edi pe stiva pentru ca vreau sa-l utilizez in cadrul procedurii + vreau sa-i restaurez valoarea in urma cadrului de apel
...
popl %edi 	<-- %edi si-a primit inapoi vechea lui valoare
popl %esi	<-- am restaurat vechea valoare a lui %esi
popl %ebx	<-- descarc in %ebx continutul din varful stivei obtinand, in acest mod, vechea valoare a lui %ebx 

%edi v 
%esi v 
%ebx v
<adr de intoarcere>
x
y

O completare pentru %ebp: pentru a-l putea utiliza, avem nevoie de urmatorii doi pasi
1. se face push cu vechea valoare a lui %ebp pe stiva, fix la intrarea in cadrul de apel;
2. se face %ebp pointer in cadrul de apel, astfel incat elementele de pe stiva sa poata fi accesate in raport cu acesta.

pushl %ebp		<-- am pus valoarea lui %ebp pe stiva, pentru ca si %ebp trebuie restaurat
movl %esp, %ebp		<-- %ebp = %esp 


Cum arata stiva pentru suma a doua numere:

suma(x, y)

%edi v			<-- %esp	-8(%ebp)
%ebx v			 		-4(%ebp)
%ebp v			<-- %ebp	 0(%ebp)
<adr de intoarcere>  			 4(%ebp)
x					 8(%ebp) 
y					12(%ebp)

Respectarea conventiilor asigura si posibilitatea de implementare a procedurilor recursive si a call-urilor imbricate. (de exemplu, in procedura care determina cate elemente maxime avem intr-un array, putem face call catre o procedura care ne da maximul din array-ul respectiv). 

Returnarea valorilor se face prin intermediul registrului %eax. Daca implementez suma a doua numere, ma astept ca, la revenirea din apel, sa gasesc rezultatul stocat in registrul %eax. 

%eax = suma(x, y).

long suma (long x, long y)
{
	return %eax;
}


Sa se implementeze o procedura care sa verifice daca un argument dat este numar perfect (egal cu suma divizorilor sai pana la jumatate).

perfect(long x) care returneaza prin %eax valoarea 1 daca x este perfect si 0 altfel

perfect(28) <-- 1 in %eax
perfect(13) <-- 0 in %eax

si afisati pe ecran "Numarul ... dat ca argument este numar perfect\n", respectiv "Numarul ... dat ca argument NU este numar perfect \n".


